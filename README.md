# IntelligentPlacer
Лабораторная работа по курсу "Основы машинного обучения"
____
# Постановка задачи
Необходимо создать python-библиотеку, которая по поданной на вход фотографии нескольких предметов на белой горизонтальной поверхности и нарисованному на белом листе многоугольнику позволит за приемлемое время определять, можно ли расположить одновременно все эти предметы на плоскости так, чтобы они влезли в этот многоугольник. Предметы и горизонтальная поверхность, которые могут оказаться на фотографии, заранее известны.

## Вход/Выход программы
* Программа получает на вход <b>путь до изображения</b>, содержащего предметы и многоугольник, расположенные на белой горизонтальной поверхности.
* Программа возвращает <b>булевское значение</b> — True, если все предметы, расположенные на фотографии, могут поместиться в нарисованный многоугольник; False, если предметы не помещаются в многоугольник, или если входные данные не соответствуют требованиям.

# Требования к входным данным
## Общие требования к изображению
* изображение должно иметь формат JPEG и разрешение 3024 x 4032 пикселей
* изображение должно быть цветным
* изображение не должно быть никак отредактировано
* при съемке изображения камера должна быть расположена над поверхностью, с минимальным отклонением от перпендикуляра к поверхности (допустима разумная погрешность отклонения в районе 5-10 градусов)
* источник света должен располагаться над камерой, на изображении должны отсутствовать темные и пересвеченные области
* высота съемки не должна превышать 40 см над поверхностью
* поверхность должна быть светлой, не иметь явно выделяющегося рельефа

## Требования к предметам
* все используемые предметы должны принадлежать к основному датасету (изображения расположены в директории [items](items))
* вращение предметов относительно их положения на изображениях основного датасета допускается только вокруг оси, совпадающей с нормалью к горизонтальной поверхности
* на изображении должен присутствовать хотя бы один предмет
* предметы должны полностью помещаться в кадр
* предметы должны быть расположены на белой поверхности, границы предметов должны быть хорошо визуально отделимы от фона
* предметы не должны пересекаться или касаться друг друга
* предмет может присутствовать на фотографии только один раз
* предметы не должны иметь пересечений с многоугольником и его внутренней частью
* все предметы должны быть расположены по одну сторону от многоугольника

## Требования к многоугольнику
* на изображении должен присутствовать многоугольник
* многоугольник должен быть нарисован черным маркером на белом листе формата А4, его границы должны быть хорошо визуально отделимы от листа
* многоугольник должен полностью помещаться на фото
* многоугольник должен быть замкнутым и иметь не более десяти вершин
* стороны многоугольника должны быть явно отличимы
____
# План работы
## 1. Подготовка необходимых данных о предметах набора
(идея: использовать для размещения шаблоны, полученные с помощью отдельных изображений предметов, чтобы ограничить влияние ракурса и дополнительных теней на изображении, поступающем на вход алгоритма)
* Использовать бинаризацию Оцу и морфологические операции для получения шаблонов (бинарной маски) предметов из датасета с изображениями отдельных предметов. Отобрать нужную компоненту связности, используя тот факт, что предметы находятся в центре изображения.
## 2. Распознавание предметов и многоугольника на изображении
* При распознавании необходимо по каким-то признакам отличить многоугольник от предметов. Скорее всего, распознавание многоугольника даст хороший результат при использовании детектора границ Canny, тогда как предметы стоит искать с помощью бинаризации (идея: попробовать опытным путем вычислить оптимальный порядок применения этих операций и их параметры, чтобы разделить поиск предметов и многоугольника).
* После нахождения границ многоугольника получить бинарную маску его внутренней части.
* По полученным маскам найденных предметов выбрать рабочие области для каждого из них, сегментировать изображение, после чего использовать дескриптор SIFT для сравнения особых точек изображений найденных предметов с изображениями предметов из набора. После классификации необходимо сопоставить полученные маски предметов с масками с предобработанных изображений, чтобы найти аффинное преобразование, приводящее шаблоны предметов к масштабу входного изображения.
## 3. Размещение предметов в многоугольнике 
(используем полученные маски предметов и многоугольника)
* Определить площади предметов и многоугольника, для того чтобы быстро получить результат False, когда суммарная площадь предметов больше площади многоугольника. Рассмотреть другие возможные тривиальные случаи.
* Наиболее очевидным решением задачи размещения кажется использование поочередного перебора возможных положений предметов, например, в подобном виде:
   1. выбрать среди еще не размещенных предмет с наибольшей площадью
   2. расположить предмет рядом с многоугольником
   3. перемещать его сначала по оси x, затем по оси у на заданный шаг, до тех пор, пока он не окажется полностью внутри многоугольника и при этом не будет пересекаться с другими расположенными в нем объектами
   4. если разместить не удалось, применить к маске предмета матрицу вращения на некоторый угол и повторить попытку
   5. если предмет размещен, переходим к следующему предмету, если все предметы оказались размещены — ответ True
   6. если все варианты перебраны, но предмет так и не получилось расположить — считаем, что ответ False
* Еще один подход — рассматривать задачу размещения объектов как задачу двумерной упаковки. Для решения задач данного класса разработано большое количество алгоритмов, поэтому можно попробовать свести исследуемую задачу к более простому подвиду этого класса, например, некоторым образом перейдя от многоугольников к прямоугольникам или квадратам, что, возможно, позволит эффективно использовать соответствующие эвристические методы, методы динамического программирования или генетические алгоритмы.
____
# Результаты
Ход работы над программой и примеры работы расположены в файле [workflow_and_demo.ipynb](workflow_and_demo.ipynb).
Демонстрация результатов работы программы на всем датасете и оценка качества работы алгоритма расположены в файле [algorithm_quality_assessment.ipynb](algorithm_quality_assessment.ipynb).